Got it — you want the **Flask backend to treat uploads generically**, and the **frontend will decide** whether the returned text is for the agreement or template. Let's streamline both sides.

---

## ✅ Flask Backend: Generic Upload Handler

Route: `POST /api/legaldoc/upload-one`

```python
@legaldoc_bp.route('/upload-one', methods=['POST'])
def upload_single_document():
    if 'file' not in request.files:
        return jsonify({'error': 'Missing file'}), 400

    file = request.files['file']
    filename = secure_filename(file.filename)
    filepath = os.path.join('uploads', filename)

    os.makedirs('uploads', exist_ok=True)
    file.save(filepath)

    try:
        text = textract.process(filepath).decode('utf-8')
    except Exception as e:
        return jsonify({'error': f'Failed to extract text: {str(e)}'}), 500

    return jsonify({'text': text})
```

✅ No `type` required. The backend just returns the text, and the frontend decides what to do with it.

---

## ✅ Angular Service (`legaldoc.service.ts`)

```ts
uploadDocument(file: File): Observable<any> {
  const formData = new FormData();
  formData.append('file', file);
  return this.http.post('http://localhost:5000/api/legaldoc/upload-one', formData);
}
```

---

## ✅ Angular Component (`legaldoc.component.ts`)

```ts
onFileUpload(event: any, target: 'agreement' | 'template') {
  const file = event.target.files[0];
  if (!file) return;

  this.legalDocService.uploadDocument(file).subscribe({
    next: (res) => {
      const text = res.text || '';
      if (target === 'agreement') {
        this.agreementText = text;
      } else {
        this.templateText = text;
      }
    },
    error: (err) => {
      console.error('Error uploading file:', err);
    }
  });
}
```

---

### ✅ Result:

* Backend just returns extracted text.
* Frontend uses `target` argument to assign it to `agreementText` or `templateText`.

Would you like me to help with the HTML part for file upload and preview next?
