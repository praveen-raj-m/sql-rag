Perfect — thanks for clarifying!

Since you already have `attribution.service.ts` inside the `services/` folder, we’ll do the following:

---

### ✅ Final Structure

**Frontend folder setup:**

```
src/
├── app/
│   ├── features/
│   │   └── attribution/
│   │       ├── attribution.component.ts
│   │       └── attribution.component.html
│   ├── services/
│   │   └── attribution.service.ts  ← We’ll add chat logic here
```

---

### ✅ Step-by-Step Update

#### 1. **Update `attribution.service.ts`**

Add this function to handle the chat API call:

```ts
sendChat(
  model: string,
  temperature: number,
  dataJson: any,
  history: { role: 'user' | 'assistant', content: string }[],
  userQuery: string
): Observable<{ response: string }> {
  const url = 'http://localhost:5000/chat';
  return this.http.post<{ response: string }>(url, {
    model,
    temperature,
    dataJson,
    history,
    userQuery
  });
}
```

> 💡 Make sure `HttpClient` is already injected in the constructor:

```ts
constructor(private http: HttpClient) {}
```

---

#### 2. **Use it inside `attribution.component.ts`**

Update the constructor:

```ts
constructor(private attributionService: AttributionService) {}
```

Then use:

```ts
sendChat() {
  const query = this.chatInput.trim();
  if (!query) return;

  this.chatHistory.push({ role: 'user', content: query });
  this.chatInput = '';
  this.isChatLoading = true;

  const history = this.chatHistory.slice(-6); // trim to recent messages
  this.attributionService.sendChat(
    this.llmModel,
    this.temperature,
    this.attributionJson,  // store this during generate prompt
    history,
    query
  ).subscribe({
    next: (res) => {
      this.chatHistory.push({ role: 'assistant', content: res.response });
      this.isChatLoading = false;
    },
    error: (err) => {
      console.error('Chat error:', err);
      this.chatHistory.push({ role: 'assistant', content: '⚠️ Error getting response.' });
      this.isChatLoading = false;
    }
  });
}
```

---

Let me know when this is working — then we’ll build the backend `/chat` route in Flask to receive and respond!
