def generate_attribution_prompt(csv_data: str, analyst_name: str, analysis_date: str):
    import csv
    import io

    headers = [
        "sector", "portfolio_avg_weight", "portfolio_total_return", "portfolio_weighted_contribution",
        "benchmark_avg_weight", "benchmark_total_return", "benchmark_weighted_contribution",
        "variance_avg_weight", "variance_total_return", "variance_weighted_contribution",
        "allocation", "selection", "total_management"
    ]

    reader = csv.reader(io.StringIO(csv_data.replace(",,", ",").strip()))
    rows = []

    for row in reader:
        if len(row) < 13:
            continue  # Skip malformed rows
        cleaned = [col.strip() for col in row]
        entry = {headers[i]: cleaned[i] if i == 0 else float(cleaned[i]) for i in range(13)}
        rows.append(entry)

    # Remove and store total row separately
    total_row = next((r for r in rows if r['sector'].lower() == 'total'), None)
    rows = [r for r in rows if r['sector'].lower() != 'total']

    # Sort by total_management descending
    sorted_rows = sorted(rows, key=lambda x: x['total_management'], reverse=True)

    # Tagging top and bottom 3
    for idx, row in enumerate(sorted_rows):
        if idx < 3:
            row['tag'] = f"top_{idx+1}"
        elif idx >= len(sorted_rows) - 3:
            row['tag'] = f"bottom_{len(sorted_rows) - idx}"

    # Append total row at the end
    if total_row:
        sorted_rows.append(total_row)

    analyst_block = f"Analyst: {analyst_name}\n" if analyst_name else ""
    date_block = f"Analysis Date: {analysis_date}\n" if analysis_date else ""

    prompt = (
        f"{analyst_block}{date_block}"
        f"You are a financial analyst. Analyze the following performance attribution data. "
        f"Focus especially on the sectors tagged with top_ and bottom_ labels. "
        f"Summarize the portfolio performance, highlight key contributors and detractors, "
        f"and write in a professional tone suitable for a client-facing report.\n\n"
        f"Data:\n{sorted_rows}"
    )

    return prompt
